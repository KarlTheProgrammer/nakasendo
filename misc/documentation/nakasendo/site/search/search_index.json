{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What it does? Nakasendo TM is a cryptographic library and toolset that can be used to enhance the security of any cryptocurrency exchange and, more broadly, ensure the effective control of access to any type of digital asset or resource.","title":"Nakasendo SDK"},{"location":"#what-it-does","text":"Nakasendo TM is a cryptographic library and toolset that can be used to enhance the security of any cryptocurrency exchange and, more broadly, ensure the effective control of access to any type of digital asset or resource.","title":"What it does?"},{"location":"DeveloperSetup/","text":"In order to develop/contribute to Nakasendo, it is required to install and prepare some dev environments. It consist of installing tools/libraries for C++/Python/Javascript. It is recommended to Build from source when it is Linux environment Download prebuilt binaries when it is Windows environment Install everything in the same location and define environment variables poiting to the installed location. The build system will find them appropriately C++ libraries and tools CMake 3.14.7 C++ Compiler: Visual Studio Community Edition 2017 on windows, g++7 on Linux Boost 1.69.0 to build CPP unit tests ( download prebuild binaries for windows ) OpenSSL 1.1.b : It needs two versions: one for native C++, the other for emcripten. The prebuilt openssl for Emscripten can be downloaded from https://bitbucket.org/nch-atlassian/sdklibraries/downloads/ Protobuf 3.11.0 : either on Windows or Linux, compile it from source and install it. Then name the system variable Protobuf_ROOT pointing to its installation location. See detail in $SDK_SOURCE/cmake/modules/FindProtobufHelper.cmake Tools for javascript EMSDK: 1.38.0 Use install and activate to install components Clone the EMSDK Git repository Pull latest changes From the newly created EMSDK repository's root directory, perform \"emsdk list\" to see the installable versions Choose the latest minor version of 1.38 e.g. \"emsdk install 1.38.48\" On Windows, run \"emsdk\" instead of \"./emsdk\", and \"emsdk_env.bat\" instead of \"source ./emsdk_env.sh\". Install the following tools, using \"emsdk list\" clang e.g. emsdk install clang-e1.38.30-64bit emscripten e.g. emsdk install emscripten-1.38.30 node (need to install modules mocha , mocha-junit-reporter using NPM command: \"npm install --global mocha mocha-junit-reporter\") binaryen (not required but useful tools) e.g. emsdk install binaryen-tag-1.38.30-64bit napi : TODO Python 3.7.3 (64-bit) As part of the Python Windows installer, ensure to check the installation options for the \"Download debugging symbols\" and the \"Download debug binaries (requires VS 2015 or later)\" checkboxes. pathlib useful pytest to run Python tests junitparser to combine overall junit test results ecdsa to study elliptic curves requests to send http(s) request to different server APIs (Jenkins/ Bitbucket) mkdocs , pymdown-extensions plantuml_markdown to build documentations with mkdocs You can do it all at once after installing python nchain@sdk:~$ python -m pip install pathlib pytest junitparser ecdsa requests mkdocs pymdown-extensions plantuml_markdown NSIS 3.04 This is required for windows only, to build windows installer. Environment setup Once the build tools and libraries are prepared, some post installation steps are required to let the SDKLibraries build system know how to find everything: Add C:\\Development\\repos\\emsdk\\clang\\e1.38.30_64bit to the path too Add emscripten path to path as well Add the directory of CMake executable to the environment variable PATH Add the directory of Python3 executable to the environment variable PATH Add the directory of Emscripten executable to the environment variable PATH Set environment variable BOOST_ROOT pointing to the root of the Boost installation Set environment variable OPENSSL_ROOT_DIR pointing to the root of the OpenSSL for C++ installation Set environment variable OPENSSL_WASM_ROOT_DIR pointing to the root of the OpenSSL for Emscripten installation The SDKLibraries can be built on any system, as long as all libraries and required tools are manually compiled to ensure absolute compatibility. Users can choose the appropriate CMake generator to make the build. The CMake build allows everything to be built separately from the source to keep the source repository clean. After cloning the source code to \"SDKLibraries\" directory, create a \"build\" directory alongside this, then run the cmake/make command to build Compile/test/pack On Windows C:\\development\\build> cmake -G\"Visual Studio 15 2017\" -A x64 ..\\SDKLibraries && cmake --build . --target ALL_BUILD --config Debug && cmake --build . --target ALL_BUILD --config Release && ctest -C Debug && ctest -C Release && cpack -G NSIS -C Release On Linux nchain@sdk:~$ cmake ../SDKLibraries -DCMAKE_BUILD_TYPE=Debug -DCUSTOM_SYSTEM_OS_NAME=Ubuntu; time -p make -j8 ; ctest ; cpack -G TGZ To run all tests nchain@sdk:~$ ctest # or \"make test\" on linux C:\\nchain\\sdk> ctest -C Release # On Windows C:\\nchain\\sdk> ctest -C Debug # On Windows","title":"Developer setup"},{"location":"DeveloperSetup/#c-libraries-and-tools","text":"CMake 3.14.7 C++ Compiler: Visual Studio Community Edition 2017 on windows, g++7 on Linux Boost 1.69.0 to build CPP unit tests ( download prebuild binaries for windows ) OpenSSL 1.1.b : It needs two versions: one for native C++, the other for emcripten. The prebuilt openssl for Emscripten can be downloaded from https://bitbucket.org/nch-atlassian/sdklibraries/downloads/ Protobuf 3.11.0 : either on Windows or Linux, compile it from source and install it. Then name the system variable Protobuf_ROOT pointing to its installation location. See detail in $SDK_SOURCE/cmake/modules/FindProtobufHelper.cmake","title":"C++ libraries and tools"},{"location":"DeveloperSetup/#tools-for-javascript","text":"EMSDK: 1.38.0 Use install and activate to install components Clone the EMSDK Git repository Pull latest changes From the newly created EMSDK repository's root directory, perform \"emsdk list\" to see the installable versions Choose the latest minor version of 1.38 e.g. \"emsdk install 1.38.48\" On Windows, run \"emsdk\" instead of \"./emsdk\", and \"emsdk_env.bat\" instead of \"source ./emsdk_env.sh\". Install the following tools, using \"emsdk list\" clang e.g. emsdk install clang-e1.38.30-64bit emscripten e.g. emsdk install emscripten-1.38.30 node (need to install modules mocha , mocha-junit-reporter using NPM command: \"npm install --global mocha mocha-junit-reporter\") binaryen (not required but useful tools) e.g. emsdk install binaryen-tag-1.38.30-64bit napi : TODO","title":"Tools for javascript"},{"location":"DeveloperSetup/#python-373-64-bit","text":"As part of the Python Windows installer, ensure to check the installation options for the \"Download debugging symbols\" and the \"Download debug binaries (requires VS 2015 or later)\" checkboxes. pathlib useful pytest to run Python tests junitparser to combine overall junit test results ecdsa to study elliptic curves requests to send http(s) request to different server APIs (Jenkins/ Bitbucket) mkdocs , pymdown-extensions plantuml_markdown to build documentations with mkdocs You can do it all at once after installing python nchain@sdk:~$ python -m pip install pathlib pytest junitparser ecdsa requests mkdocs pymdown-extensions plantuml_markdown","title":"Python 3.7.3 (64-bit)"},{"location":"DeveloperSetup/#nsis-304","text":"This is required for windows only, to build windows installer.","title":"NSIS 3.04"},{"location":"DeveloperSetup/#environment-setup","text":"Once the build tools and libraries are prepared, some post installation steps are required to let the SDKLibraries build system know how to find everything: Add C:\\Development\\repos\\emsdk\\clang\\e1.38.30_64bit to the path too Add emscripten path to path as well Add the directory of CMake executable to the environment variable PATH Add the directory of Python3 executable to the environment variable PATH Add the directory of Emscripten executable to the environment variable PATH Set environment variable BOOST_ROOT pointing to the root of the Boost installation Set environment variable OPENSSL_ROOT_DIR pointing to the root of the OpenSSL for C++ installation Set environment variable OPENSSL_WASM_ROOT_DIR pointing to the root of the OpenSSL for Emscripten installation The SDKLibraries can be built on any system, as long as all libraries and required tools are manually compiled to ensure absolute compatibility. Users can choose the appropriate CMake generator to make the build. The CMake build allows everything to be built separately from the source to keep the source repository clean. After cloning the source code to \"SDKLibraries\" directory, create a \"build\" directory alongside this, then run the cmake/make command to build","title":"Environment setup"},{"location":"DeveloperSetup/#compiletestpack","text":"On Windows C:\\development\\build> cmake -G\"Visual Studio 15 2017\" -A x64 ..\\SDKLibraries && cmake --build . --target ALL_BUILD --config Debug && cmake --build . --target ALL_BUILD --config Release && ctest -C Debug && ctest -C Release && cpack -G NSIS -C Release On Linux nchain@sdk:~$ cmake ../SDKLibraries -DCMAKE_BUILD_TYPE=Debug -DCUSTOM_SYSTEM_OS_NAME=Ubuntu; time -p make -j8 ; ctest ; cpack -G TGZ To run all tests nchain@sdk:~$ ctest # or \"make test\" on linux C:\\nchain\\sdk> ctest -C Release # On Windows C:\\nchain\\sdk> ctest -C Debug # On Windows","title":"Compile/test/pack"},{"location":"Examples/","text":"Examples in C++ BigNumber BigNumber val; std::string SumA(\"\"); std::string AVal = \"c590e57ee64fced18aff6e2f0c6ac05625b1e94f394f42470cae14d12cadea4f5ab6b9d77225fe3b4903825966c78752ae51b6a0a2caca555fd0ffcbd9704b01\"; std::string BVal(\"219639ed8afc21e052422fff0ae5583231ebca2999404b099628093e6540b1dbc20b9c495aa7229b5965b19a5fcd653b3fa0eccab567c5b5e8\"); BigNumber BNValA, BNValB; BNValA.FromHex(AVal); BNValB.FromHex(BVal); std::cout << BNValA.ToHex() << \"\\n\" << BNValB.ToHex() << std::endl; BigNumber Sum = BNValA + BNValB; std::cout << Sum.ToHex() << std::endl; TODO : pick examaples in examples/cpp, quote here and explain them Examples in Python Key split and recover mykey = Nakasendo.ECKey256K1(); print (mykey) shares = mykey.SplitKey(5,15); print(shares) #At some point later.... print (\"a random collection of shares\") secure_random = random.SystemRandom() subset = [] sharesCopy = shares random.shuffle (sharesCopy) for i in range(5): subset.append(sharesCopy[i]) print(subset) recoveredKey = Nakasendo.ECKey256K1() recoveredKey.RecoverKey(subset) print(recoveredKey) TODO : pick examaples in examples/python, quote here and explain them Examples in Javascript Random big number generator const rand_hex_str = JSBigNumbers.RandHex(128); TODO : pick examaples in NapiBinding/test, quote here and explain them","title":"Examples"},{"location":"Examples/#examples-in-c","text":"BigNumber BigNumber val; std::string SumA(\"\"); std::string AVal = \"c590e57ee64fced18aff6e2f0c6ac05625b1e94f394f42470cae14d12cadea4f5ab6b9d77225fe3b4903825966c78752ae51b6a0a2caca555fd0ffcbd9704b01\"; std::string BVal(\"219639ed8afc21e052422fff0ae5583231ebca2999404b099628093e6540b1dbc20b9c495aa7229b5965b19a5fcd653b3fa0eccab567c5b5e8\"); BigNumber BNValA, BNValB; BNValA.FromHex(AVal); BNValB.FromHex(BVal); std::cout << BNValA.ToHex() << \"\\n\" << BNValB.ToHex() << std::endl; BigNumber Sum = BNValA + BNValB; std::cout << Sum.ToHex() << std::endl; TODO : pick examaples in examples/cpp, quote here and explain them","title":"Examples in C++"},{"location":"Examples/#examples-in-python","text":"Key split and recover mykey = Nakasendo.ECKey256K1(); print (mykey) shares = mykey.SplitKey(5,15); print(shares) #At some point later.... print (\"a random collection of shares\") secure_random = random.SystemRandom() subset = [] sharesCopy = shares random.shuffle (sharesCopy) for i in range(5): subset.append(sharesCopy[i]) print(subset) recoveredKey = Nakasendo.ECKey256K1() recoveredKey.RecoverKey(subset) print(recoveredKey) TODO : pick examaples in examples/python, quote here and explain them","title":"Examples in Python"},{"location":"Examples/#examples-in-javascript","text":"Random big number generator const rand_hex_str = JSBigNumbers.RandHex(128); TODO : pick examaples in NapiBinding/test, quote here and explain them","title":"Examples in Javascript"},{"location":"Guides/","text":"Elliptic Curves In Bitcoin, private/public key pairs are based on elliptic curves groups. An elliptic curve E E satisfies the equation \\begin{equation} y^2 \\equiv x^3 + ax + b \\bmod p \\end{equation} \\begin{equation} y^2 \\equiv x^3 + ax + b \\bmod p \\end{equation} where a, b \\in \\mathbb{Z}_p a, b \\in \\mathbb{Z}_p for some prime p p , satisfying 4a^3 + 27b^2 \\neq 0 4a^3 + 27b^2 \\neq 0 . The group over this elliptic curve is defined to be E \\cup \\{ {\\mathcal{O}} \\} E \\cup \\{ {\\mathcal{O}} \\} where \\{ {\\mathcal{O}} \\} \\{ {\\mathcal{O}} \\} , is the identity element called the point at ininity, and the elements of E E are of the form (x,y) (x,y) satisfying the equation above. The group E \\cup \\{ {\\mathcal{O}} \\} E \\cup \\{ {\\mathcal{O}} \\} under point addition '+' '+' has order n n and we will denote a generator of this group by G G . For a point G\\in E \\cup \\{ {\\mathcal{O}} \\} G\\in E \\cup \\{ {\\mathcal{O}} \\} and a scalar d \\in \\mathbb{Z}_n d \\in \\mathbb{Z}_n , point scalar multiplicaion is written as d\\cdot G d\\cdot G and defined to be the point G G added to itself d d times. Given a point d\\cdot G d\\cdot G , it is computationally infeasible to calculate d d . In Bitcoin, private keys are chosen to be this value d d , and the public keys are then d\\cdot G d\\cdot G . The elliptic curve is chosen to be the secp256k1 curve, which has the following parameters: a=0 a=0 b=7 b=7 p=2^{256}-2^{32}-2^9-2^8-2^7-2^6-2^4-1 p=2^{256}-2^{32}-2^9-2^8-2^7-2^6-2^4-1 n=\\mathrm{FFFFFFFF \\; FFFFFFFF \\; FFFFFFFF \\; FFFFFFFE \\; BAAEDCE6 \\; AF48A03B \\; BFD25E8C \\; D0364141} n=\\mathrm{FFFFFFFF \\; FFFFFFFF \\; FFFFFFFF \\; FFFFFFFE \\; BAAEDCE6 \\; AF48A03B \\; BFD25E8C \\; D0364141} G=\\mathrm{ (79BE667E \\; F9DCBBAC \\; 55A06295 \\; CE870B07 \\; 029BFCDB \\; 2DCE28D9 \\; 59F2815B \\; 16F81798, \\\\ \\; 483ADA77 \\; 26A3C465 \\; 5DA4FBFC \\; 0E1108A8 \\; FD17B448 \\; A6855419 \\; 9C47D08F \\; FB10D4B8) } G=\\mathrm{ (79BE667E \\; F9DCBBAC \\; 55A06295 \\; CE870B07 \\; 029BFCDB \\; 2DCE28D9 \\; 59F2815B \\; 16F81798, \\\\ \\; 483ADA77 \\; 26A3C465 \\; 5DA4FBFC \\; 0E1108A8 \\; FD17B448 \\; A6855419 \\; 9C47D08F \\; FB10D4B8) } Private keys can be used to create signatures on a message, that can be verified against the corresponding public key. Elliptic Curve Digital Signature Algorithm In order to create a signature on a message M M , with the private key d d , the following steps are taken. Calculate the message digest e = \\mathrm{SHA256}\\left(\\mathrm{SHA256}(M)\\right) e = \\mathrm{SHA256}\\left(\\mathrm{SHA256}(M)\\right) , where \\mathrm{SHA256}(\\bullet) \\mathrm{SHA256}(\\bullet) is the SHA256 hash function. Chose a random integer k \\in \\{1,\\ldots, n-1\\} k \\in \\{1,\\ldots, n-1\\} , where n n is the order of the secp256k1 curve. We will refer to k k as the ephemeral key. Calculate the ephemeral public key corresponding to this ephemeral private key $$ k \\cdot G = (x,y) \\; . $$ Caclulate r=x \\bmod n r=x \\bmod n . If r=0 r=0 , return to step 1. Calculate the multiplicative inverse of the ephemeral key k^{-1} k^{-1} modulo n n . Caclulate s=k^{-1}(e+ar) \\bmod n s=k^{-1}(e+ar) \\bmod n . If s=0 s=0 , return to step 1. The signature on the message M M is (r,s) (r,s) . The ephemeral key must be kept secret, otherwise the private key can be calculated given a message and signature. Additionally, each time a signature is generated, a different ephemeral key must be used. If this is not the case, it is possible to derive the private key d d given two different signatures and their corresponding messages. Given a messae M M , a public key d\\cdot G d\\cdot G , and corresponding signature (r,s) (r,s) , then one can verify the signature by completing the following steps. Calculate the message digest e=\\mathrm{SHA256}(\\mathrm{SHA256}(M)) e=\\mathrm{SHA256}(\\mathrm{SHA256}(M)) . Calculate the multiplicative inverse s^{-1} s^{-1} of s s modulo n n . Calculate j_1=es^{-1} \\bmod n j_1=es^{-1} \\bmod n and j_2=rs^{-1} \\bmod n j_2=rs^{-1} \\bmod n . Calculate the point Q=j_1\\cdot G+j_2 (d\\cdot G) Q=j_1\\cdot G+j_2 (d\\cdot G) . If Q=\\mathcal{O} Q=\\mathcal{O} , the point at infinity, the signature is invalid. If Q\\neq \\mathcal{O} Q\\neq \\mathcal{O} , then let Q:=(x,y) Q:=(x,y) , and calculate t=x \\bmod n t=x \\bmod n . If t=r t=r , the signature is valid. It is possible to split the private key d d into key shares, that can be distributed among parties, and then set a threshold number of parties who can come together to sign a message in the way described above. This process of splitting a key and calculating a signature uses concepts of polynomials. Polynomials A polynomial of order t t has the form \\begin{equation} f(x) = a_0 + a_1x + \\ldots + a_{t-1}x^{t-1} + a_t x^t \\bmod n \\end{equation} \\begin{equation} f(x) = a_0 + a_1x + \\ldots + a_{t-1}x^{t-1} + a_t x^t \\bmod n \\end{equation} and points on this polynomial will be denoted by \\begin{equation} (x_i, y_i) \\end{equation} \\begin{equation} (x_i, y_i) \\end{equation} where y_i = f(x_i) y_i = f(x_i) . The zeroth order of the polyomial will correspond to the shared private key d d . Each participant's key share is a point on this polynomial (x_i,y_i) (x_i,y_i) where i=1,\\ldots ,M i=1,\\ldots ,M , and M M is the number of participants. It is possible to use t+1 t+1 of these points to recalculate the polynomial. This is done using Lagrange interpolation. Lagrange Interpolation In order to calculate an order- t t poylnomial, given at least t+1 t+1 points labelled \\begin{equation} (x_1, y_1), \\ldots, (x_{t+1}, y_{t+1}) \\end{equation} \\begin{equation} (x_1, y_1), \\ldots, (x_{t+1}, y_{t+1}) \\end{equation} on the polynomial f(x) f(x) , one can use the following equation \\begin{equation} f(x) = \\sum_{i=1}^{t+1} y_i \\prod_{\\substack{ 1\\leq j \\leq t+1, \\\\ j \\neq i}}(x-x_j)\\cdot(x_i-x_j)^{-1} \\bmod n \\; . \\end{equation} \\begin{equation} f(x) = \\sum_{i=1}^{t+1} y_i \\prod_{\\substack{ 1\\leq j \\leq t+1, \\\\ j \\neq i}}(x-x_j)\\cdot(x_i-x_j)^{-1} \\bmod n \\; . \\end{equation} If this expression is evaluated at 0, i.e. f(0) f(0) is calculated, then the result of this will be exactly the zeroth order of the polynomial a_0 a_0 . As mentioned, this will be chosen to be the shared secret. We will denote interpolation of t+1 t+1 shares, labelled a_i a_i for i=1,\\ldots, t+1 i=1,\\ldots, t+1 , at 0 by interpolate(a_1,\\ldots, a_{t+1}) interpolate(a_1,\\ldots, a_{t+1}) \\begin{equation} interpolate(a_1,\\ldots, a_{t+1}) := \\sum_{i=1}^{t+1} y_i \\prod_{\\substack{ 1\\leq j \\leq t+1, \\\\ j \\neq i}}(-x_j)\\cdot(x_i-x_j)^{-1} \\bmod n \\; . \\end{equation} \\begin{equation} interpolate(a_1,\\ldots, a_{t+1}) := \\sum_{i=1}^{t+1} y_i \\prod_{\\substack{ 1\\leq j \\leq t+1, \\\\ j \\neq i}}(-x_j)\\cdot(x_i-x_j)^{-1} \\bmod n \\; . \\end{equation} Note that if the interpolation is over less thatn t+1 t+1 shares, the polynomial, and therefore shared secret a_0 a_0 , cannot be calculated. Secret Key Sharing Secret key sharing may refer to the concept of splitting a private key into multiple shares which can be stored independently, or it may refer to the process of two parties establishing a shared secret in a secure way. Both these methods are used in this implementation and so are described below. The first is achieved using Joint Verifiable Random Secret Sharing, and the second is Diffie-Hellman key exchange. Joint Verifiable Random Secret Sharing A group of M M participants can create a shared secret using the concepts described above, such that t+1 t+1 of the group are required to calculate the shared secret. The shares of this shared secret can be calculated without ever calculating the shared secret itself, and this can be doing in a verifiable way. This method is called 'Joint Verifiable Random Secret Sharing', commonly referred to as JVRSS. This method JVRSS is split into two parts: creating shared secret shares, and verifying the shared secret shares. Creating the shares In order to create shared secret d d between N N participants, without any one party knowing the secret, and where t+1 t+1 of the participants are required to calculate the secret, the following steps are taken. Note that each participant has a unique label i=1,\\ldots N i=1,\\ldots N that they all agree on. Each participant i i randomly generates t+1 t+1 integers d_{i0},\\ldots, d_{it} \\in \\mathbb{Z}_n d_{i0},\\ldots, d_{it} \\in \\mathbb{Z}_n , which are used to define a private polynomial for each participant i i $$ f_i(x) = d_{i0}+ d_{i1}x+\\ldots + d_{it} x^t \\bmod n $$ These N N polynomials will be used to create a shared polynomial, which in turn will define a shared secret. Note that since the aim is to establish a shared private key which is in the group \\mathbb{Z}_n \\mathbb{Z}_n where n n is the order of the elliptic curve group, the polynomials are calculated modulo n n . Each participant i i sends the value f_i(j) f_i(j) to participant j j only using a secure communication channel with participant j j . It is crucial that this is shared only betweeen i i and j j or there will be enough information between participants for any of them to calculate the shared secret, contradicting the aim of the JVRSS process. Each participant i i calculates their own secret share of the shared secret by calculating $$ d_i = \\sum_{j=1}^N f_j(i) \\bmod n \\; .$$ These d_i d_i along with a participants label i i are the secret shares, that is, a participants i i secret share is (i,d_i) (i,d_i) , and these shares can be used in the formula for Langrange interpolation to calculate the shared secret d d which is defined to be $$ d := \\sum_{i=1}^N d_{i0} \\bmod n \\; . $$ Verifying the shares The participants can now verify that the other participants have sent the correct point on their own private polynomials by following the steps below. Each participant i i broadcasts the following information $$ d_{ik}\\cdot G $$ for k=0,\\ldots t k=0,\\ldots t . Here 'broadcast' means that each participant knows that all other participants recieved the same information. Each participant i i can check that each participant j j has calculated this polynomial point f_j(i) f_j(i) from the coefficients d_{j0}, \\ldots, d_{jt} d_{j0}, \\ldots, d_{jt} using the values $$ d_{jk}\\cdot G $$ that are shared in step 1 of the verification. This is done by participant i i calculating $$ f_j(i) \\cdot G \\stackrel{?}{=} \\sum_{k=0}^t i^k(d_{jk}\\cdot G) $$ for j=1,\\ldots, M j=1,\\ldots, M , where f_j(i) \\cdot G f_j(i) \\cdot G is calculated from the value shared in the second step of the setup. If these checks hold, then participants can be certain that all parties have the same shared secret. Calculating the shared public key Finally, all pariticpants can calculate the shared public key using the information shared in step 1 of the verification. Each participant calculates D := d\\cdot G = \\sum_{i=0}^{N} (d_{i0}\\cdot G) D := d\\cdot G = \\sum_{i=0}^{N} (d_{i0}\\cdot G) where the right hand side can be calculated from the values (d_{i0}\\cdot G) (d_{i0}\\cdot G) shared in step 1 of the verification, and the public key is now calculated without ever knowing d d explicitly. In the following, the calculation and verification of secret shares for a particpant labelled by i i will be referred to as JVRSS(i) JVRSS(i) . We saw that in step 2, each pair of participants needs to establish a secure communication channel to share the points on the private polynomials. This requires a method for each pair to set up a common secret, which can be used to encrypt the points on the private polynomials, and then they can be shared with the other party securely. This is the second interpretation of the phrase 'secret key sharing', and one method for this is elliptic curve Diffie-Hellman key exchange. Elliptic Curve Diffie-Hellman key exchange This is a method for two entities to create a common secret across an unsecure network, by calculating the secret independently at each entity. Assume that Alice and Bob want to share a secret across an unsecure communication channel. Alice and Bob agree on an elliptic curve scheme. The setup is as follows. They each randomly genearte their own private key: i. Alice generates her private key d_A \\in \\{0,\\ldots, n-1\\} d_A \\in \\{0,\\ldots, n-1\\} and calculates her corresponding public key D_A = d_A\\cdot G D_A = d_A\\cdot G . Recall that n n is the order of the elliptic curve group. ii. Bob generates his private key D_B = d_B \\in \\{0,\\ldots, n-1\\} D_B = d_B \\in \\{0,\\ldots, n-1\\} , and calculates his corresponding public key d_B\\cdot G d_B\\cdot G . They share their public keys over the unsecure network. They each use their own private key and the other's public to calculate a common secret. i. Alice calculates the common secret using D_{AB}= d_A D_B = d_A(d_B\\cdot G) D_{AB}= d_A D_B = d_A(d_B\\cdot G) . ii. Bob calculates the common secret using D_{AB}= d_B D_A = d_A(d_B\\cdot G) D_{AB}= d_B D_A = d_A(d_B\\cdot G) . They now both know the value D_{AB} D_{AB} and no one else is able to calculate this, hence it is a common secret. This method can be shown in the diagram below. DIAGRAM of DH Key Management Once a secret is established, it is recommended to use a similar concept of JVRSS to split the secret into multiple shares, and stored separately for security. In this case, the process is simpler as the secret that is being split is known by the party splitting it. This also means that there is no need for the verification steps. To split a secret D_{AB} D_{AB} into multiple shares, requiring \\tau+1 \\tau+1 shares to calculate the secret, the following steps are taken. Put the shared secret D_{AB} D_{AB} in the form of a compressed point. That is, the x x -value preceeded with the byte 02 or 03 depending on whether the y y -value is even or odd, respectively. Generate \\tau \\tau random integers c_1,\\ldots c_{\\tau} \\in \\mathbb{Z}_{?} c_1,\\ldots c_{\\tau} \\in \\mathbb{Z}_{?} , and define a polynomial $$ f_{(D_{AB})}(x)= D_{AB} + c_1 x + c_2 x^2 +\\ldots + c_{\\tau} x^{\\tau} \\bmod {???} \\; . $$ Label points on this polynomial by $$ (1,y_1), \\ldots, (\\eta, y_{\\eta}) $$ where y_j=f_{(D_{AB})}(j) y_j=f_{(D_{AB})}(j) for j=1,\\ldots , \\eta j=1,\\ldots , \\eta and \\eta>\\tau \\eta>\\tau is the number of shares that the secret is being split into. These points on the polynomial are now the shares of the secret D_{AB} D_{AB} that must be stored independently, and the secret is secure unless \\tau+1 \\tau+1 of these shares are compromised. In order to reconstruct the secret D_{AB} D_{AB} , one uses Lagrange interpolation over \\tau+1 \\tau+1 of the shares. Symmetric Encryption Symmetric encryption refers to a type of encryption where the same secret key is used to encrypt and decrypt a ciphertext. Therefore if two parties are able to create a shared secret such as using Diffie-Hellman described above, they can use symmetric encryption and share ciphertexts over unsecure communication channels securely. Some common symmetric encryption schemes include the Data Encryption Standard (DES), Advanced Encryption Standard (AES), or Rivest Cipher 4 (RC4). The most secure symmetric encryption standard is called message authenticated HMAC AES 256-bit continuous block cipher (is this how it is called?), and been chosen as the standard in the SDK software for this reason. This encryption includes the HMAC of the plaintext message in the encryption of the plaintext, such that after decryption, the reciever can verify that the message was not compromised in transmission. Threshold Signatures An M M -of- N N threshold signature scheme is a scheme where any M M of a group of N N players can collaborate to create a signature. With a threshold signature scheme described below, the secret key that is signing the message is never generated explicitly. The signature also appears to any external party as a signature with a single party. Because the full private key is not stored anywhere, there is no single point of failure. If a share is compromised, the adversary learns nothing about the shared key. In fact, for a secret threshold of t+1 t+1 , up to t t of the shares can compromised and the secret will still be safe. For a secret threshold of t+1 t+1 , the required number of signers is M=2t+1 M=2t+1 . This is due to the multiparty computation requiring the multiplication of two shared secrets. This implies that for a secret threshold of t+1 t+1 , there must be n=2t+1 n=2t+1 participants of the scheme, or it would not be possible to create a signature with the process described below. Threshold signatures is achieved using a combination of JVRSS and Lagrange interpolation. The calculation of a threshold signature can be split into two processes: setup, and signature calculation. The setup of the system can be done at any time before the signature calculation. The setup can be split into two subparts: the calculation of the shared secret key, and the calculation of a shared ephemeral key, which is used in the signature. As mentioned, the ephemeral key used in a signature must be kept secret, otherwise the private key can be calculated. Since the private key is a shared secret which no party knows, this implies that the ephemeral key must also be a shared secret. Setup To create a shared secret key, the N N participants in the scheme exectute JVRSS and public key calculation as described above. This results in each participant i i having a private key share (d_i, D) (d_i, D) , where D=d\\cdot G D=d\\cdot G , and label the threshold of the secret by t+1 t+1 . In order to create a shared ephemeral key with threshold t+1 t+1 , the following steps are taken. All participants take part in JVRSS to establish a shared ephemeral key, so participant i i has the share k_i=JVRSS(i) k_i=JVRSS(i) . Each particpant calculates the public key corresponding to the ephmeral key $$ R := (x,y)=\\sum_{i=1}^{N} k_{i0}\\cdot G $$ and the first part of the signature is the result of $$ r=x \\bmod n $$ where n n is the order of the elliptic curve. All participants take part in JVRSS to establish a shared blinding value \\alpha \\alpha with threshold t+1 t+1 , so participant i i has the share \\alpha_i=JVRSS(i) \\alpha_i=JVRSS(i) . Each participant i i calculates their share of the multiplicative secret $$ v_i = k_i \\alpha_i \\bmod n \\; . $$ All participants broadcast their multiplicative share v_i v_i to the other participants. Each participant interpolates over 2t+1 2t+1 of the shares v_i v_i to calculate $$ v=k\\alpha = interpolate(v_1,\\ldots, v_{2t+1}) \\; . $$ Each participant calculates the modular inverse of the result $$ v^{-1} = k^{-1} \\alpha^{-1} \\bmod n \\; . $$ Each participant calculates their inverse key share $$ k_i^{-1} = k^{-1} \\alpha^{-1} \\alpha_i \\bmod n \\; . $$ Each participant i i stores the result (r,k_i^{-1}) (r,k_i^{-1}) for use in the calculation of signatures. As metioned this a different ephemeral key needs to be used for different signatures and it is recommended that multiple of these shared ephemeral keys are created in the setup stage. Signature generation In order for M M of the participants to create a signature on a message with the private key d d , the following steps are taken. A coordinator requests a signature on the message from at least M M of the participants in the scheme. Each participant i i uses the next ephemeral key (r,k_i^{-1}) (r,k_i^{-1}) and marks it as used. All participants must use the shares corresponding to the same ephemeral key. Each participant calculates the message digest e = SHA256(SHA256(message)) e = SHA256(SHA256(message)) . Each participant calculates their own signature share s_i s_i $$ s_i = k_i^{-1} (e + d_i r) \\bmod n $$ where d_i d_i is their private key share. Each participant sents their signature share (r,s_i) (r,s_i) to the coordinator. When the coordinator has recieved M M signature shares, they interpolate over the shares to find $$ s= interpolate(s_1,\\ldots, s_{M}) $$ and output the signature as (r,s) (r,s) . The coordinator verifies the signature using the normal ECDSA verification described above. If this fails, at least one of the shares must be incorrect and the signature generation algorithm should be run again. The communication rounds of the threshold signature algorthm are shown in the diagrams below. Sequence diagram round 1 Sequence diagram round 2 Sequence diagram round 3","title":"Guides"},{"location":"Guides/#elliptic-curves","text":"In Bitcoin, private/public key pairs are based on elliptic curves groups. An elliptic curve E E satisfies the equation \\begin{equation} y^2 \\equiv x^3 + ax + b \\bmod p \\end{equation} \\begin{equation} y^2 \\equiv x^3 + ax + b \\bmod p \\end{equation} where a, b \\in \\mathbb{Z}_p a, b \\in \\mathbb{Z}_p for some prime p p , satisfying 4a^3 + 27b^2 \\neq 0 4a^3 + 27b^2 \\neq 0 . The group over this elliptic curve is defined to be E \\cup \\{ {\\mathcal{O}} \\} E \\cup \\{ {\\mathcal{O}} \\} where \\{ {\\mathcal{O}} \\} \\{ {\\mathcal{O}} \\} , is the identity element called the point at ininity, and the elements of E E are of the form (x,y) (x,y) satisfying the equation above. The group E \\cup \\{ {\\mathcal{O}} \\} E \\cup \\{ {\\mathcal{O}} \\} under point addition '+' '+' has order n n and we will denote a generator of this group by G G . For a point G\\in E \\cup \\{ {\\mathcal{O}} \\} G\\in E \\cup \\{ {\\mathcal{O}} \\} and a scalar d \\in \\mathbb{Z}_n d \\in \\mathbb{Z}_n , point scalar multiplicaion is written as d\\cdot G d\\cdot G and defined to be the point G G added to itself d d times. Given a point d\\cdot G d\\cdot G , it is computationally infeasible to calculate d d . In Bitcoin, private keys are chosen to be this value d d , and the public keys are then d\\cdot G d\\cdot G . The elliptic curve is chosen to be the secp256k1 curve, which has the following parameters: a=0 a=0 b=7 b=7 p=2^{256}-2^{32}-2^9-2^8-2^7-2^6-2^4-1 p=2^{256}-2^{32}-2^9-2^8-2^7-2^6-2^4-1 n=\\mathrm{FFFFFFFF \\; FFFFFFFF \\; FFFFFFFF \\; FFFFFFFE \\; BAAEDCE6 \\; AF48A03B \\; BFD25E8C \\; D0364141} n=\\mathrm{FFFFFFFF \\; FFFFFFFF \\; FFFFFFFF \\; FFFFFFFE \\; BAAEDCE6 \\; AF48A03B \\; BFD25E8C \\; D0364141} G=\\mathrm{ (79BE667E \\; F9DCBBAC \\; 55A06295 \\; CE870B07 \\; 029BFCDB \\; 2DCE28D9 \\; 59F2815B \\; 16F81798, \\\\ \\; 483ADA77 \\; 26A3C465 \\; 5DA4FBFC \\; 0E1108A8 \\; FD17B448 \\; A6855419 \\; 9C47D08F \\; FB10D4B8) } G=\\mathrm{ (79BE667E \\; F9DCBBAC \\; 55A06295 \\; CE870B07 \\; 029BFCDB \\; 2DCE28D9 \\; 59F2815B \\; 16F81798, \\\\ \\; 483ADA77 \\; 26A3C465 \\; 5DA4FBFC \\; 0E1108A8 \\; FD17B448 \\; A6855419 \\; 9C47D08F \\; FB10D4B8) } Private keys can be used to create signatures on a message, that can be verified against the corresponding public key.","title":"Elliptic Curves"},{"location":"Guides/#elliptic-curve-digital-signature-algorithm","text":"In order to create a signature on a message M M , with the private key d d , the following steps are taken. Calculate the message digest e = \\mathrm{SHA256}\\left(\\mathrm{SHA256}(M)\\right) e = \\mathrm{SHA256}\\left(\\mathrm{SHA256}(M)\\right) , where \\mathrm{SHA256}(\\bullet) \\mathrm{SHA256}(\\bullet) is the SHA256 hash function. Chose a random integer k \\in \\{1,\\ldots, n-1\\} k \\in \\{1,\\ldots, n-1\\} , where n n is the order of the secp256k1 curve. We will refer to k k as the ephemeral key. Calculate the ephemeral public key corresponding to this ephemeral private key $$ k \\cdot G = (x,y) \\; . $$ Caclulate r=x \\bmod n r=x \\bmod n . If r=0 r=0 , return to step 1. Calculate the multiplicative inverse of the ephemeral key k^{-1} k^{-1} modulo n n . Caclulate s=k^{-1}(e+ar) \\bmod n s=k^{-1}(e+ar) \\bmod n . If s=0 s=0 , return to step 1. The signature on the message M M is (r,s) (r,s) . The ephemeral key must be kept secret, otherwise the private key can be calculated given a message and signature. Additionally, each time a signature is generated, a different ephemeral key must be used. If this is not the case, it is possible to derive the private key d d given two different signatures and their corresponding messages. Given a messae M M , a public key d\\cdot G d\\cdot G , and corresponding signature (r,s) (r,s) , then one can verify the signature by completing the following steps. Calculate the message digest e=\\mathrm{SHA256}(\\mathrm{SHA256}(M)) e=\\mathrm{SHA256}(\\mathrm{SHA256}(M)) . Calculate the multiplicative inverse s^{-1} s^{-1} of s s modulo n n . Calculate j_1=es^{-1} \\bmod n j_1=es^{-1} \\bmod n and j_2=rs^{-1} \\bmod n j_2=rs^{-1} \\bmod n . Calculate the point Q=j_1\\cdot G+j_2 (d\\cdot G) Q=j_1\\cdot G+j_2 (d\\cdot G) . If Q=\\mathcal{O} Q=\\mathcal{O} , the point at infinity, the signature is invalid. If Q\\neq \\mathcal{O} Q\\neq \\mathcal{O} , then let Q:=(x,y) Q:=(x,y) , and calculate t=x \\bmod n t=x \\bmod n . If t=r t=r , the signature is valid. It is possible to split the private key d d into key shares, that can be distributed among parties, and then set a threshold number of parties who can come together to sign a message in the way described above. This process of splitting a key and calculating a signature uses concepts of polynomials.","title":"Elliptic Curve Digital Signature Algorithm"},{"location":"Guides/#polynomials","text":"A polynomial of order t t has the form \\begin{equation} f(x) = a_0 + a_1x + \\ldots + a_{t-1}x^{t-1} + a_t x^t \\bmod n \\end{equation} \\begin{equation} f(x) = a_0 + a_1x + \\ldots + a_{t-1}x^{t-1} + a_t x^t \\bmod n \\end{equation} and points on this polynomial will be denoted by \\begin{equation} (x_i, y_i) \\end{equation} \\begin{equation} (x_i, y_i) \\end{equation} where y_i = f(x_i) y_i = f(x_i) . The zeroth order of the polyomial will correspond to the shared private key d d . Each participant's key share is a point on this polynomial (x_i,y_i) (x_i,y_i) where i=1,\\ldots ,M i=1,\\ldots ,M , and M M is the number of participants. It is possible to use t+1 t+1 of these points to recalculate the polynomial. This is done using Lagrange interpolation.","title":"Polynomials"},{"location":"Guides/#lagrange-interpolation","text":"In order to calculate an order- t t poylnomial, given at least t+1 t+1 points labelled \\begin{equation} (x_1, y_1), \\ldots, (x_{t+1}, y_{t+1}) \\end{equation} \\begin{equation} (x_1, y_1), \\ldots, (x_{t+1}, y_{t+1}) \\end{equation} on the polynomial f(x) f(x) , one can use the following equation \\begin{equation} f(x) = \\sum_{i=1}^{t+1} y_i \\prod_{\\substack{ 1\\leq j \\leq t+1, \\\\ j \\neq i}}(x-x_j)\\cdot(x_i-x_j)^{-1} \\bmod n \\; . \\end{equation} \\begin{equation} f(x) = \\sum_{i=1}^{t+1} y_i \\prod_{\\substack{ 1\\leq j \\leq t+1, \\\\ j \\neq i}}(x-x_j)\\cdot(x_i-x_j)^{-1} \\bmod n \\; . \\end{equation} If this expression is evaluated at 0, i.e. f(0) f(0) is calculated, then the result of this will be exactly the zeroth order of the polynomial a_0 a_0 . As mentioned, this will be chosen to be the shared secret. We will denote interpolation of t+1 t+1 shares, labelled a_i a_i for i=1,\\ldots, t+1 i=1,\\ldots, t+1 , at 0 by interpolate(a_1,\\ldots, a_{t+1}) interpolate(a_1,\\ldots, a_{t+1}) \\begin{equation} interpolate(a_1,\\ldots, a_{t+1}) := \\sum_{i=1}^{t+1} y_i \\prod_{\\substack{ 1\\leq j \\leq t+1, \\\\ j \\neq i}}(-x_j)\\cdot(x_i-x_j)^{-1} \\bmod n \\; . \\end{equation} \\begin{equation} interpolate(a_1,\\ldots, a_{t+1}) := \\sum_{i=1}^{t+1} y_i \\prod_{\\substack{ 1\\leq j \\leq t+1, \\\\ j \\neq i}}(-x_j)\\cdot(x_i-x_j)^{-1} \\bmod n \\; . \\end{equation} Note that if the interpolation is over less thatn t+1 t+1 shares, the polynomial, and therefore shared secret a_0 a_0 , cannot be calculated.","title":"Lagrange Interpolation"},{"location":"Guides/#secret-key-sharing","text":"Secret key sharing may refer to the concept of splitting a private key into multiple shares which can be stored independently, or it may refer to the process of two parties establishing a shared secret in a secure way. Both these methods are used in this implementation and so are described below. The first is achieved using Joint Verifiable Random Secret Sharing, and the second is Diffie-Hellman key exchange.","title":"Secret Key Sharing"},{"location":"Guides/#joint-verifiable-random-secret-sharing","text":"A group of M M participants can create a shared secret using the concepts described above, such that t+1 t+1 of the group are required to calculate the shared secret. The shares of this shared secret can be calculated without ever calculating the shared secret itself, and this can be doing in a verifiable way. This method is called 'Joint Verifiable Random Secret Sharing', commonly referred to as JVRSS. This method JVRSS is split into two parts: creating shared secret shares, and verifying the shared secret shares. Creating the shares In order to create shared secret d d between N N participants, without any one party knowing the secret, and where t+1 t+1 of the participants are required to calculate the secret, the following steps are taken. Note that each participant has a unique label i=1,\\ldots N i=1,\\ldots N that they all agree on. Each participant i i randomly generates t+1 t+1 integers d_{i0},\\ldots, d_{it} \\in \\mathbb{Z}_n d_{i0},\\ldots, d_{it} \\in \\mathbb{Z}_n , which are used to define a private polynomial for each participant i i $$ f_i(x) = d_{i0}+ d_{i1}x+\\ldots + d_{it} x^t \\bmod n $$ These N N polynomials will be used to create a shared polynomial, which in turn will define a shared secret. Note that since the aim is to establish a shared private key which is in the group \\mathbb{Z}_n \\mathbb{Z}_n where n n is the order of the elliptic curve group, the polynomials are calculated modulo n n . Each participant i i sends the value f_i(j) f_i(j) to participant j j only using a secure communication channel with participant j j . It is crucial that this is shared only betweeen i i and j j or there will be enough information between participants for any of them to calculate the shared secret, contradicting the aim of the JVRSS process. Each participant i i calculates their own secret share of the shared secret by calculating $$ d_i = \\sum_{j=1}^N f_j(i) \\bmod n \\; .$$ These d_i d_i along with a participants label i i are the secret shares, that is, a participants i i secret share is (i,d_i) (i,d_i) , and these shares can be used in the formula for Langrange interpolation to calculate the shared secret d d which is defined to be $$ d := \\sum_{i=1}^N d_{i0} \\bmod n \\; . $$ Verifying the shares The participants can now verify that the other participants have sent the correct point on their own private polynomials by following the steps below. Each participant i i broadcasts the following information $$ d_{ik}\\cdot G $$ for k=0,\\ldots t k=0,\\ldots t . Here 'broadcast' means that each participant knows that all other participants recieved the same information. Each participant i i can check that each participant j j has calculated this polynomial point f_j(i) f_j(i) from the coefficients d_{j0}, \\ldots, d_{jt} d_{j0}, \\ldots, d_{jt} using the values $$ d_{jk}\\cdot G $$ that are shared in step 1 of the verification. This is done by participant i i calculating $$ f_j(i) \\cdot G \\stackrel{?}{=} \\sum_{k=0}^t i^k(d_{jk}\\cdot G) $$ for j=1,\\ldots, M j=1,\\ldots, M , where f_j(i) \\cdot G f_j(i) \\cdot G is calculated from the value shared in the second step of the setup. If these checks hold, then participants can be certain that all parties have the same shared secret. Calculating the shared public key Finally, all pariticpants can calculate the shared public key using the information shared in step 1 of the verification. Each participant calculates D := d\\cdot G = \\sum_{i=0}^{N} (d_{i0}\\cdot G) D := d\\cdot G = \\sum_{i=0}^{N} (d_{i0}\\cdot G) where the right hand side can be calculated from the values (d_{i0}\\cdot G) (d_{i0}\\cdot G) shared in step 1 of the verification, and the public key is now calculated without ever knowing d d explicitly. In the following, the calculation and verification of secret shares for a particpant labelled by i i will be referred to as JVRSS(i) JVRSS(i) . We saw that in step 2, each pair of participants needs to establish a secure communication channel to share the points on the private polynomials. This requires a method for each pair to set up a common secret, which can be used to encrypt the points on the private polynomials, and then they can be shared with the other party securely. This is the second interpretation of the phrase 'secret key sharing', and one method for this is elliptic curve Diffie-Hellman key exchange.","title":"Joint Verifiable Random Secret Sharing"},{"location":"Guides/#elliptic-curve-diffie-hellman-key-exchange","text":"This is a method for two entities to create a common secret across an unsecure network, by calculating the secret independently at each entity. Assume that Alice and Bob want to share a secret across an unsecure communication channel. Alice and Bob agree on an elliptic curve scheme. The setup is as follows. They each randomly genearte their own private key: i. Alice generates her private key d_A \\in \\{0,\\ldots, n-1\\} d_A \\in \\{0,\\ldots, n-1\\} and calculates her corresponding public key D_A = d_A\\cdot G D_A = d_A\\cdot G . Recall that n n is the order of the elliptic curve group. ii. Bob generates his private key D_B = d_B \\in \\{0,\\ldots, n-1\\} D_B = d_B \\in \\{0,\\ldots, n-1\\} , and calculates his corresponding public key d_B\\cdot G d_B\\cdot G . They share their public keys over the unsecure network. They each use their own private key and the other's public to calculate a common secret. i. Alice calculates the common secret using D_{AB}= d_A D_B = d_A(d_B\\cdot G) D_{AB}= d_A D_B = d_A(d_B\\cdot G) . ii. Bob calculates the common secret using D_{AB}= d_B D_A = d_A(d_B\\cdot G) D_{AB}= d_B D_A = d_A(d_B\\cdot G) . They now both know the value D_{AB} D_{AB} and no one else is able to calculate this, hence it is a common secret. This method can be shown in the diagram below. DIAGRAM of DH","title":"Elliptic Curve Diffie-Hellman key exchange"},{"location":"Guides/#key-management","text":"Once a secret is established, it is recommended to use a similar concept of JVRSS to split the secret into multiple shares, and stored separately for security. In this case, the process is simpler as the secret that is being split is known by the party splitting it. This also means that there is no need for the verification steps. To split a secret D_{AB} D_{AB} into multiple shares, requiring \\tau+1 \\tau+1 shares to calculate the secret, the following steps are taken. Put the shared secret D_{AB} D_{AB} in the form of a compressed point. That is, the x x -value preceeded with the byte 02 or 03 depending on whether the y y -value is even or odd, respectively. Generate \\tau \\tau random integers c_1,\\ldots c_{\\tau} \\in \\mathbb{Z}_{?} c_1,\\ldots c_{\\tau} \\in \\mathbb{Z}_{?} , and define a polynomial $$ f_{(D_{AB})}(x)= D_{AB} + c_1 x + c_2 x^2 +\\ldots + c_{\\tau} x^{\\tau} \\bmod {???} \\; . $$ Label points on this polynomial by $$ (1,y_1), \\ldots, (\\eta, y_{\\eta}) $$ where y_j=f_{(D_{AB})}(j) y_j=f_{(D_{AB})}(j) for j=1,\\ldots , \\eta j=1,\\ldots , \\eta and \\eta>\\tau \\eta>\\tau is the number of shares that the secret is being split into. These points on the polynomial are now the shares of the secret D_{AB} D_{AB} that must be stored independently, and the secret is secure unless \\tau+1 \\tau+1 of these shares are compromised. In order to reconstruct the secret D_{AB} D_{AB} , one uses Lagrange interpolation over \\tau+1 \\tau+1 of the shares.","title":"Key Management"},{"location":"Guides/#symmetric-encryption","text":"Symmetric encryption refers to a type of encryption where the same secret key is used to encrypt and decrypt a ciphertext. Therefore if two parties are able to create a shared secret such as using Diffie-Hellman described above, they can use symmetric encryption and share ciphertexts over unsecure communication channels securely. Some common symmetric encryption schemes include the Data Encryption Standard (DES), Advanced Encryption Standard (AES), or Rivest Cipher 4 (RC4). The most secure symmetric encryption standard is called message authenticated HMAC AES 256-bit continuous block cipher (is this how it is called?), and been chosen as the standard in the SDK software for this reason. This encryption includes the HMAC of the plaintext message in the encryption of the plaintext, such that after decryption, the reciever can verify that the message was not compromised in transmission.","title":"Symmetric Encryption"},{"location":"Guides/#threshold-signatures","text":"An M M -of- N N threshold signature scheme is a scheme where any M M of a group of N N players can collaborate to create a signature. With a threshold signature scheme described below, the secret key that is signing the message is never generated explicitly. The signature also appears to any external party as a signature with a single party. Because the full private key is not stored anywhere, there is no single point of failure. If a share is compromised, the adversary learns nothing about the shared key. In fact, for a secret threshold of t+1 t+1 , up to t t of the shares can compromised and the secret will still be safe. For a secret threshold of t+1 t+1 , the required number of signers is M=2t+1 M=2t+1 . This is due to the multiparty computation requiring the multiplication of two shared secrets. This implies that for a secret threshold of t+1 t+1 , there must be n=2t+1 n=2t+1 participants of the scheme, or it would not be possible to create a signature with the process described below. Threshold signatures is achieved using a combination of JVRSS and Lagrange interpolation. The calculation of a threshold signature can be split into two processes: setup, and signature calculation. The setup of the system can be done at any time before the signature calculation. The setup can be split into two subparts: the calculation of the shared secret key, and the calculation of a shared ephemeral key, which is used in the signature. As mentioned, the ephemeral key used in a signature must be kept secret, otherwise the private key can be calculated. Since the private key is a shared secret which no party knows, this implies that the ephemeral key must also be a shared secret. Setup To create a shared secret key, the N N participants in the scheme exectute JVRSS and public key calculation as described above. This results in each participant i i having a private key share (d_i, D) (d_i, D) , where D=d\\cdot G D=d\\cdot G , and label the threshold of the secret by t+1 t+1 . In order to create a shared ephemeral key with threshold t+1 t+1 , the following steps are taken. All participants take part in JVRSS to establish a shared ephemeral key, so participant i i has the share k_i=JVRSS(i) k_i=JVRSS(i) . Each particpant calculates the public key corresponding to the ephmeral key $$ R := (x,y)=\\sum_{i=1}^{N} k_{i0}\\cdot G $$ and the first part of the signature is the result of $$ r=x \\bmod n $$ where n n is the order of the elliptic curve. All participants take part in JVRSS to establish a shared blinding value \\alpha \\alpha with threshold t+1 t+1 , so participant i i has the share \\alpha_i=JVRSS(i) \\alpha_i=JVRSS(i) . Each participant i i calculates their share of the multiplicative secret $$ v_i = k_i \\alpha_i \\bmod n \\; . $$ All participants broadcast their multiplicative share v_i v_i to the other participants. Each participant interpolates over 2t+1 2t+1 of the shares v_i v_i to calculate $$ v=k\\alpha = interpolate(v_1,\\ldots, v_{2t+1}) \\; . $$ Each participant calculates the modular inverse of the result $$ v^{-1} = k^{-1} \\alpha^{-1} \\bmod n \\; . $$ Each participant calculates their inverse key share $$ k_i^{-1} = k^{-1} \\alpha^{-1} \\alpha_i \\bmod n \\; . $$ Each participant i i stores the result (r,k_i^{-1}) (r,k_i^{-1}) for use in the calculation of signatures. As metioned this a different ephemeral key needs to be used for different signatures and it is recommended that multiple of these shared ephemeral keys are created in the setup stage. Signature generation In order for M M of the participants to create a signature on a message with the private key d d , the following steps are taken. A coordinator requests a signature on the message from at least M M of the participants in the scheme. Each participant i i uses the next ephemeral key (r,k_i^{-1}) (r,k_i^{-1}) and marks it as used. All participants must use the shares corresponding to the same ephemeral key. Each participant calculates the message digest e = SHA256(SHA256(message)) e = SHA256(SHA256(message)) . Each participant calculates their own signature share s_i s_i $$ s_i = k_i^{-1} (e + d_i r) \\bmod n $$ where d_i d_i is their private key share. Each participant sents their signature share (r,s_i) (r,s_i) to the coordinator. When the coordinator has recieved M M signature shares, they interpolate over the shares to find $$ s= interpolate(s_1,\\ldots, s_{M}) $$ and output the signature as (r,s) (r,s) . The coordinator verifies the signature using the normal ECDSA verification described above. If this fails, at least one of the shares must be incorrect and the signature generation algorithm should be run again. The communication rounds of the threshold signature algorthm are shown in the diagrams below.","title":"Threshold Signatures"},{"location":"Guides/#sequence-diagram-round-1","text":"","title":"Sequence diagram round 1"},{"location":"Guides/#sequence-diagram-round-2","text":"","title":"Sequence diagram round 2"},{"location":"Guides/#sequence-diagram-round-3","text":"","title":"Sequence diagram round 3"},{"location":"QuickStart/","text":"Installation and setting SDK Download the appropriate nakasendo installer and install to your system. The best way to make the examples work is to define the environment variable SDKLIBRARIES_ROOT pointing to the location where SDKLibraries is installed. C++ examples On Windows, you'll need Visual Studio Community Edition 2017 and CMake 3.14.7. On Linux, you'll need gcc7, cmake 3.12 or newer. On Windows, run the following command e.g: C:\\nchain\\sdk> cmake -G\"Visual Studio 15 2017\" -A x64 \"%SDKLIBRARIES_ROOT%\\example\\cpp\" This will create the Visual Studio solution (.sln) file. Add %SDKLIBRARIES_ROOT%\\lib to your %PATH% Open the .sln file in Visual Studio and you can start to Build and Run the C++ examples. [You may also have to install Twisted, Python 3, pip3, ecdsa, nodejs and npm] On Linux (Ubuntu 18.04), run the command : nchain@sdk:~$ cmake -DCMAKE_BUILD_TYPE=Debug \"$SDKLIBRARIES_ROOT/example/cpp\" ; make -j4 It will create a Makefile project and build it. You can start to compile/run the c++ examples Python examples Python examples need to know where to find all the python modules. If you have defined the variable SDKLIBRARIES_ROOT correctly, just open python files and run it normally. Otherway is to define the PYTHONPATH variable pointing to the installation of SDKLibraries (where it have all module files) and run it Note that on windows, if you have a debug version of SDK installation, you should use the python_d interpreter instead of python Javascript examples To run javascript example, you need a http server. The simplest way is to use python to run the http server. Open the terminal, go to $SDKLIBRARIES_ROOT/example/javascript, run the comnmand : nchain@sdk:~$ python -m http.server Then from the browser, open localhost:8000","title":"QuickStart"},{"location":"QuickStart/#installation-and-setting-sdk","text":"Download the appropriate nakasendo installer and install to your system. The best way to make the examples work is to define the environment variable SDKLIBRARIES_ROOT pointing to the location where SDKLibraries is installed.","title":"Installation and setting SDK"},{"location":"QuickStart/#c-examples","text":"On Windows, you'll need Visual Studio Community Edition 2017 and CMake 3.14.7. On Linux, you'll need gcc7, cmake 3.12 or newer. On Windows, run the following command e.g: C:\\nchain\\sdk> cmake -G\"Visual Studio 15 2017\" -A x64 \"%SDKLIBRARIES_ROOT%\\example\\cpp\" This will create the Visual Studio solution (.sln) file. Add %SDKLIBRARIES_ROOT%\\lib to your %PATH% Open the .sln file in Visual Studio and you can start to Build and Run the C++ examples. [You may also have to install Twisted, Python 3, pip3, ecdsa, nodejs and npm] On Linux (Ubuntu 18.04), run the command : nchain@sdk:~$ cmake -DCMAKE_BUILD_TYPE=Debug \"$SDKLIBRARIES_ROOT/example/cpp\" ; make -j4 It will create a Makefile project and build it. You can start to compile/run the c++ examples","title":"C++ examples"},{"location":"QuickStart/#python-examples","text":"Python examples need to know where to find all the python modules. If you have defined the variable SDKLIBRARIES_ROOT correctly, just open python files and run it normally. Otherway is to define the PYTHONPATH variable pointing to the installation of SDKLibraries (where it have all module files) and run it Note that on windows, if you have a debug version of SDK installation, you should use the python_d interpreter instead of python","title":"Python examples"},{"location":"QuickStart/#javascript-examples","text":"To run javascript example, you need a http server. The simplest way is to use python to run the http server. Open the terminal, go to $SDKLIBRARIES_ROOT/example/javascript, run the comnmand : nchain@sdk:~$ python -m http.server Then from the browser, open localhost:8000","title":"Javascript examples"}]}